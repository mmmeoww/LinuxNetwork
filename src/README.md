# REPORT

## Part 1. Инструмент ipcalc
* Установил ipcalc с помощью команды ```sudo apt install ipcalc```

![img1](./pictures/1.png)

1. Сети и маски 
    1. Определил адрес сети 192.167.38.54/13 командой ```ipcalc 192.167.38.54/13``` (Network: 192.160.0.0/13)

    ![img2](./pictures/2.png)

    2. Перевел маски 255.255.255.0 в префиксную и двоичную запись, /15 в обычную и двоичную, 11111111.11111111.11111111.11110000 в обычную и префиксную

    ![img3](./pictures/3.png)

    3. Определил минимальный и максимальный хост (отмечены как HostMin и HostMax) в сети 12.167.38.4 при масках: /8, 11111111.11111111.00000000.00000000, 255.255.254.0 и /4

    ![img4](./pictures/4.png)

    ![img5](./pictures/5.png)

2. localhost
    1. Определил, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1

    ![img6](./pictures/6.png)

    ![img7](./pictures/7.png)

    Для обращения на localhost могут использоваться только адреса из 127.0.0.0/8. В выводе команды ```ipcalc``` для этих адресов должно присутствовать loopback. Т. е. подходят адреса 127.0.0.2 и 127.1.0.1.
3. Диапазоны и сегменты сетей
    1. С помощью ipcalc можно определить публичные и частные ip. Если вывод команды в последеней строке ```Hosts/Net``` содержит ```Private Internet```, то ip - частный.

        ![img8](./pictures/8.png)

    То есть адреса 10.0.0.45, 192.168.4.2, 172.20.250.4, 172.16.255.255, 10.10.10.10  являются частными.

    2. У сети 10.10.0.0/18 возможные адреса: 10.10.0.2, 10.10.10.10, 10.10.1.255 (Определяется по HostMin и HostMax).

        ![img9](./pictures/9.png)

## Part 2. Статическая маршрутизация между двумя машинами
1. Поднял 2 виртуальные машины ws1 и ws2.
2. С помощью команды ```ip a``` посмотрел существующие сетевые интерфейсы.

    ![img10](./pictures/10.png)

3. Задал следующие адреса и маски: ws1 — 192.168.100.10, маска /16, ws2 — 172.24.116.8, маска /12 с помощью ```sudo nano /etc/netplan/00-installer-config.yaml```. Затем перезапустил сервис сети командой ```sudo netplan apply``` и  проверил установленные адреса ```ip a```.

    ![img11](./pictures/11.png)

    ![img12](./pictures/12.png)

4. С помощью ```sudo ip r add``` добавил статические маршруты между машинами и пропинговал соединение между ними.

    ![img13](./pictures/13.png)

    ![img14](./pictures/14.png)

5. Перезапустил машины (Прежние маршруты не сохранены). Добавил статические маршруты с помощью```sudo nano /etc/netplan/00-installer-config.yaml```, хатем применил настройки ```sudo netplan apply``` и проверил соединение пингованием (0% packet loss).

    ![img15](./pictures/15.png)
    
## Part 3. Утилита iperf3
1.  8 Mbps = 1 MB/s,
    100 MB/s = 800000 Kbps,
    1 Gbps = 1000 Mbps,
2. Установил утилиту iperf3 на обе машины. С помощью нее измерил скорость соединения между ws1 и ws2.

    ![img16](./pictures/16.png)

3. На ws1 ввел команду ```iperf3 -s``` для приема входящего соединения, на ws2 - ```iperf -c 172.24.116.8``` для подключения к ws1. Результаты показали скорость 3,87 Гбит/с.
    
    ![img17](./pictures/17.png)

    ![img18](./pictures/18.png)

4. Аналогично для ws2 и ws1. В результате получил скорость 3,78 Гбит/с. 
    
    ![img19](./pictures/20.png)

    ![img20](./pictures/19.png)

## Part 4. Сетевой экран
1. iptables

    1. На ws1 и ws2 создал и отредактировал файл /etc/firewall.sh, где -А - добавление правила, -p - протокол, --dport - порт для трафика, -j - цель правила.
            
        ![img21](./pictures/21.png)

        ![img22](./pictures/22.png) 
        
    2. Запустил файлы на машинах.

        ![img23](./pictures/23.png)

    3. Пропинговал машины. Так как правила выполняются сверху вниз, вторые правила в конфигах не сработают. Поэтому ws1 не будет отвечать на пинг-запросы (echo reply), а ws2 - будет. 

        ![img24](./pictures/24.png)

        ![img25](./pictures/25.png)

2. nmap
    1. Запустил команду nmap 192.168.100.10, видно, что хост машины запущен (Host is up).

        ![img26](./pictures/26.png)

## Part 5. Статическая маршрутизация сети
1. Настройка адресов машин
    1. Настроил конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.

        ![net](./pictures/part5.png)

        ![img27](./pictures/27.png)

        ![img28](./pictures/28.png)

        ![img29](./pictures/29.png)

        ![img30](./pictures/30.png)

        ![img31](./pictures/31.png)

    2. Перезапустил сервис сети командой ```sudo netplan apply``` и проверил командой ```ip -4 a```, что адрес машины задан верно.

        ![img32](./pictures/32.png)

        ![img33](./pictures/33.png)

        ![img34](./pictures/34.png)

        ![img35](./pictures/35.png)

        ![img36](./pictures/36.png)

    3. Также пропинговал ws22 с ws21 и  r1 с ws11.
        
        ![img37](./pictures/37.png)

        ![img38](./pictures/38.png)

2. Включение переадресации IP-адресов
    1. Для включения переадресации IP выполни команду на роутерах:
        ```sysctl -w net.ipv4.ip_forward=1```, при этом после перезагрузки переадресация перестанет работать.

        ![img39](./pictures/39.png)

        ![img40](./pictures/40.png)

    2. Для постоянной переадресации в файле /etc/sysctl.conf раcкомментировал строку net.ipv4.ip_forward = 1.

        ![img41](./pictures/41.png)

        ![img42](./pictures/42.png)

3. Установка маршрута по умолчанию
    1. Настроил маршрут по умолчанию (шлюз) для рабочих станций. Для этого добавил default перед IP-роутера в файле конфигураций.

        ![img43](./pictures/43.png)
    
    2. Командой ```ip r``` вывел добавленные маршруты. 

        ![img44](./pictures/44.png)

        ![img45](./pictures/45.png)

        ![img46](./pictures/46.png)

    3. Пропинговал с ws11 роутер r2 и показал командой ```tcpdump -tn -i enp0s3``` на r2, что пинг доходит (ICMP echo request). Ответы обратно к ws11 не доходят, т.к. нет шлюза у r2 для ответа к ws11.

        ![img47](./pictures/47.png)

        ![img48](./pictures/48.png) 

4. Добавление статических маршрутов

    1. Добавил в роутеры r1 и r2 статические маршруты в файле конфигураций.

        ![img49](./pictures/49.png)

        ![img50](./pictures/50.png) 

    2. Командой ```ip route show``` проверил, что маршруты добавлены

        ![img51](./pictures/51.png)

        ![img53](./pictures/53.png) 
    
    3. На ws11 запустил команды ```ip r list 10.10.0.0/18``` ```ip r list 0.0.0.0/0```.

        ![img54](./pictures/54.png)

        В Linux маршруты выбираются по принципу наибольшего совпадения (longest prefix match). Это означает, что если есть несколько подходящих маршрутов, выбирается более конкретизированный (как парвило с более длинной маской). Default route используется для адресов с неизвестных сетей.
    
5. Построение списка маршрутизаторов
    1. Запустил команду дампа ```tcpdump -tnv enp0s3```
    2. Командой ```traceroute 10.20.0.10``` построил список маршрутизаторов на пути от ws11 до ws21.

        ![img55](./pictures/55.png)

        ![img56](./pictures/56.png)

    ```traceroute``` использует TTL (Time To Live) в IP-пакетах, чтобы определить каждый промежуточный хоп (роутер) на пути к цели, отправляя каждый раз пакет с увеличивающимся TTL (0, 1, ...).
    Cхема работы traceroute:
        ws11 (10.10.0.2)  
        [TTL=1] r1 (10.10.0.1)   
        [TTL=2] r2 (10.100.0.12)    
        [TTL=3] 10.20.0.10 (финальный ответ)
6. Использование протокола ICMP при маршрутизации
    1. Запустил на r1 перехват трафиика ```tcpdump -n -i eth0 icmp```
    2. Пропинговал с ws11 10.30.0.111 (несуществующий)
         
        ![img57](./pictures/57.png)

        ![img58](./pictures/58.png)

    Пинг не проходит, потому что r1 не знает маршрута до 10.30.0.0. r1 возвращает ICMP Destination Net Unreachable, так как не может доставить пакет.

## Part 6. Динамическая настройка IP с помощью DHCP
1. На r2 настроил в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP.

    ![img59](./pictures/59.png)

2. В файле resolv.conf записал nameserver 8.8.8.8.

    ![img60](./pictures/60.png)

3. Перезагрузил службу DHCP командой ```systemctl restart isc-dhcp-server```.

    ![img61](./pictures/61.png)

    На машинах ws21 и ws22 закомментировал статический ip адрес для автоматического получения.
    
    ![img62](./pictures/62.png)

    ![img63](./pictures/63.png)   

    Перезагрузил при помощи ```reboot``` и через ```ip a``` увидел, что они получили адрес.

    ![img64](./pictures/64.png)  

    ![img65](./pictures/65.png)

    Также пропинговал ws22 с ws21.

    ![img66](./pictures/66.png)

4. Указал MAC-адрес у ws11, для этого в ```/netplan/00-installer-config.yaml``` добавил строки: ```macaddress: 10:10:10:10:10:BA``` и ```dhcp4: true```, также закомментировал строку со статическим адресом.

    ![img67](./pictures/67.png)

5. Для r1 настроил конфиги /etc/dhcp/dhcpd.conf и resolv.conf аналогично r2, но с жесткой привязкой к MAC-адресу (ws11). 

    ![img68](./pictures/68.png)

    ![img69](./pictures/69.png)

6. Провел аналогичные тесты (Перезагрузил dhcp и ws11, ```ip a```, ping ws11 c ws21).

    ![img70](./pictures/70.png)

    ![img71](./pictures/71.png)

    ![img72](./pictures/72.png)

7. Проверил адрес через ```ip a```, затем для удаления существующего адреса использовал ```sudo dhclient -r enp0s3```, запросил новый адрес ```sudo dhclient enp0s3``` и проверил обновленный адрес.

    ![img73](./pictures/73.png)

    В данном пункте использовались следующие опции dhcp сервера: динамический ip адрес с маской подсети(10.20.0.3/26), выданный из заданного диапазона, адрес шлюза (10.20.0.1), время аренды адреса (592 sec).

## Part 7. NAT
1. В файле ```/etc/apache2/ports.conf``` на ws22 и r1 изменил строку ```Listen 80```на ```Listen 0.0.0.0:80```, то есть сделал сервер Apache2 общедоступным.

    ![img74](./pictures/74.png)

2. На обеих машинах запустил веб-сервер Apache командой ```service apache2 start```.

    ![img75](./pictures/75.png)

3. Удаление правил в таблице filter — ```iptables -F```, удаление правил в таблице «NAT» — ```iptables -F -t nat```, отбрасывать все маршрутизируемые пакеты — ```iptables --policy FORWARD DROP```. -X - для удаления настроек, созданных вручную. 

    ![img76](./pictures/76.png)

4. Запустил firewall.sh и проверил соединение ws22-r1 командой ping (ws22 c r1 не пинговалась)

    ![img77](./pictures/77.png)

    ![img78](./pictures/78.png)

5. Добавил разрешение маршрутизации всех пакетов протокола ICMP правилом ```iptables -A FORWARD -p icmp -j ACCEPT```. Запустил firewall.sh и проверил соединение (машины пингуются).

    ![img80](./pictures/80.png)

    ![img81](./pictures/81.png)

6. Включил SNAT, а именно маскирование всех локальных IP из локальной сети, находящейся за r2 (сеть 10.20.0.0). Также Включил DNAT на 8080 порт машины r2 и добавил к веб-серверу Apache, запущенному на ws22, доступ извне сети. Запустил firewall.sh

    ![img82](./pictures/82.png)

    ![img83](./pictures/83.png)

7. Перед тестированием отключил сетевой интерфейс NAT. Проверил соединение по TCP для SNAT: для этого с ws22 подключился к серверу Apache на r1 командой: ```telnet 10.10.0.1 80```, где 1 - адрес r1, 2 - порт.

    ![img84](./pictures/84.png)

    ws22 отправляет пакет на 10.10.0.1. Пакет попадает на r2, который применяет SNAT: исходный IP подменяется на 10.100.0.12 (внешний IP r2), r1 видит запрос от 10.100.0.12 и отправляет ответ обратно на r2, который уже возвращается на ws22.

8. Проверил соединение по TCP для DNAT: для этого с r1 подключиться к серверу Apache на ws22 командой ```telnet 10.100.0.12 8080```.
    ![img85](./pictures/85.png)

    r1 отправляет запрос на 10.100.0.12 (r2), целевой ip на r2 меняется на ip ws22 и перенаправляется. На обратном пути r2 меняет обратный адрес на свой. Т.е. сервер ws22 крыт для внешних клиентов.

## Part 8. Дополнительно. **SSH Tunnels**
1. Запустил на r2 фаервол с правилами из Части 7. Запустил веб-сервер **Apache** на ws22 только на localhost (то есть в файле */etc/apache2/ports.conf* изменил строку `Listen 80` на `Listen localhost:80`).

    ![img86](./pictures/86.png)

    ![img87](./pictures/87.png)

2. Воспользовался *Local TCP forwarding* с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21 командой `ssh -L 8080:localhost:80 10.20.0.48`, где -L - локальный проброс порта, 8080 - порт с запускаемой машины, localhost:80 - целевой адрес и порт, 10.20.0.48 - ip адрес сервера, к которому подключаемся. Получаем доступ к серверу ws22 c ws21.

    ![img88](./pictures/88.png)

    Для проверки, сработало ли подключение, перешел во второй терминал (Alt + F2) и выполнил команду: `telnet 127.0.0.1 8080`

    ![img89](./pictures/89.png)

    С помощью `ps aux | grep sshd` и `kill -9 PID` закрываем подключение к серверу

    ![img90](./pictures/90.png)

3. Воспользовался *Remote TCP forwarding* c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11. Так как в firewall установлено правило `iptables --policy FORWARD DROP`- oтбрасывать все маршрутизируемые пакеты, используем двойное туннелирование: 1)  на r2 выполянем локальный проброс `ssh -L 9000:localhost:80 ws22@10.20.0.19`, 9000 - порт на r2, 10.20.0.19 - адрес ws22 и 2) c ws11 выполянем удаленный (remote) проброс до r2: `ssh -R 8080:localhost:9000 ws22@10.20.0.19`. Получаем доступ к серверу ws22 на ws11.

    ![img91](./pictures/91.png)

    ![img92](./pictures/92.png)

    Для проверки аналогично выполнил ```telnet 127.0.0.1 80```

    ![img93](./pictures/93.png)
